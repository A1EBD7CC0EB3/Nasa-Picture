# How To Deploy Build Artifacts To Cloud Servers

GitHub Actions Workflow allows users to take advantage of a vast selection of open source tooling and solutions. Since the Actions Workflow 'runners' are in themselves Virtual Machines (VMs) running on cloud servers, the operating system choice for the runner dictates the syntax of run commands, the operating system commands available, and the third-party applications available for us on any particular runner.

## The GitHub Actions Workflow Architecture

To illustrate the manner through which a GitHub Actions Workflow might be employed for a CI/CD pipeline, it is important to understand the high level architecture of the GitHub Workflow runner.

The following illustration is a basic workflow runner and shows the external private of public cloud systems that might be utilized to view build artifacts, or serve as a platform for running the application built by the Actions workflow.

<table>
<tr><td>
<img width="1209" alt="Screen Shot 2019-09-23 at 11 57 07 AM" src="https://user-images.githubusercontent.com/43185011/65441953-512cda80-ddf9-11e9-8487-4a2cdd9ba5f8.png">
</td></tr>
<tr><td>
The GitHub Actions Workflow 'Runner' is a VM that launches on each workflow trigger and terminates upon workflow completion. The above architecture shows an Amazon EC2 server instance that has launched previously to receive the Build Artifacts. In this example, HTML reports are being copied to the AWS server using an Ansible Playbook. The Apache2 Web Server has been predeployed to the AWS server to allow the HTML reports to be viewed through the user's browser.
</td></tr>
</table>

### Deploying Build Unit Test Reports To An Apache2 Web Server

In DevOps environments the automation of the entire CI/CD pipeline is encouraged to allow "push button" deployments. This means that the development organization may deploy at will utilizing CI/CD tooling that oftentimes has been previously setup by operations engineers for this purpose.

In this example we assume that the enterprise organization has chosen to use Ansible for configuration management. Configuration Management is an entire process discipline unto itself and many best practices are defined to facilitate security and utilize server instances in an immutable way. Simply stated, ad hoc manual maintenance of any server instance is strongly discouraged. Instead, predefined scripts, in this case in the form of Ansible Playbooks, are created to ensure consistency, prevent human error, and allow for scalability in large infrastructure environments.

In our example, to deploy Unit Test reports generated by Maven or Gradle is a typical use case. These unit test reports are often in HTML format and the build tools are very sophisticated in their reporting capabilities. The build test reports must be persisted to a server that may serve them to a browser in an rendered format using the html and css stylesheets included by the build tool.

#### Calling an Ansible Playbook From an Actions Workflow

In this example, Gradle has been used to execute the Unit Tests and the build reports have been staged in a folder called 'test-reports' on the file system of the runner.

<table>
<tr><td>
<img width="1098" alt="Screen Shot 2019-09-23 at 12 12 27 PM" src="https://user-images.githubusercontent.com/43185011/65443118-715d9900-ddfb-11e9-854d-9028b7c624ee.png">
</td></tr>
<tr><td>
IN the above example, a private-key file is passed to the ansible-playbook commance for authentication. The Ansible Inventory file lising the servers and their dns addresses is 'ansible/inventory.yml'. The GitHub User is passed to the playbook as an environment variable. The name of the playbook run is 'ansible/copy-test-reports.yml'.
</td></tr>
</table>

##### The Inventory File

The inventory file used in the above example is in the repository and available to the runner because the repository was checked out by checkout action. 

<table>
<tr><td>
<img width="1098" alt="Screen Shot 2019-09-23 at 12 19 16 PM" src="https://user-images.githubusercontent.com/43185011/65443594-66573880-ddfc-11e9-8810-6afcafce9bd0.png">
</td></tr>
<tr><td>
The above file is a simple inventory file that enables the ansible-playbook command to access the remote aws host within the 'webservers' group.
</td></tr>
<table>

#### The Ansible Playbook

The Ansible Playbook used to copy the test reports to the remote server is named copy-test-reports.yml and is likewise placed in the ansible folder within the repository.

<table>
<tr><td>
<img width="1098" alt="Screen Shot 2019-09-23 at 12 18 04 PM" src="https://user-images.githubusercontent.com/43185011/65443491-3ad44e00-ddfc-11e9-862e-8865be744795.png">
</tr></td>
The above ansible playbook creates a directory on the remote web server for each GitHub user's (actors) test reports. It then copies the test reports from this particular workflow run to that destination on the remote server.
</td></tr>
</table>

#### A comment about Continuous Integration

In a DevOps environments when Continuous Integration is practices, the developer is encouraged to commit and puss changes from their local repo as often as possible. While it is possible to run compile processes and execute Unit tests on any developer's local workstations, many enterprises prefer that shared CI servers be used to increase transparency, ensure that the code will integrate with the work of others in real time, and ensure that the complex tooling to facilitate the process does not have to be maintained on all of the distributed developer sandbox systems. By enabling an Action Workflow to run jobs and label the output for each GitHub user, every developer is provided to see the exact output from their changes in near real-time.


